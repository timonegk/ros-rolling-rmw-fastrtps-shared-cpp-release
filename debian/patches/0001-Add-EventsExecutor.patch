From: Timon Engelke <timon.engelke@online.de>
Date: Thu, 9 Jun 2022 12:43:15 +0200
Subject: Add EventsExecutor

---
 .../custom_publisher_info.hpp                      | 10 ------
 .../custom_subscriber_info.hpp                     | 11 -------
 src/custom_publisher_info.cpp                      | 36 ----------------------
 src/custom_subscriber_info.cpp                     | 34 --------------------
 src/rmw_event.cpp                                  | 28 +----------------
 5 files changed, 1 insertion(+), 118 deletions(-)

diff --git a/include/rmw_fastrtps_shared_cpp/custom_publisher_info.hpp b/include/rmw_fastrtps_shared_cpp/custom_publisher_info.hpp
index 37db4ca..35f41d1 100644
--- a/include/rmw_fastrtps_shared_cpp/custom_publisher_info.hpp
+++ b/include/rmw_fastrtps_shared_cpp/custom_publisher_info.hpp
@@ -61,7 +61,6 @@ public:
   explicit PubListener(CustomPublisherInfo * info)
   : deadline_changes_(false),
     liveliness_changes_(false),
-    incompatible_qos_changes_(false),
     conditionMutex_(nullptr),
     conditionVariable_(nullptr)
   {
@@ -95,11 +94,6 @@ public:
     eprosima::fastdds::dds::DataWriter * writer,
     const eprosima::fastdds::dds::LivelinessLostStatus & status) final;
 
-  RMW_FASTRTPS_SHARED_CPP_PUBLIC
-  void
-  on_offered_incompatible_qos(
-    eprosima::fastdds::dds::DataWriter *,
-    const eprosima::fastdds::dds::OfferedIncompatibleQosStatus &) final;
 
   // EventListenerInterface implementation
   RMW_FASTRTPS_SHARED_CPP_PUBLIC
@@ -152,10 +146,6 @@ private:
   eprosima::fastdds::dds::LivelinessLostStatus liveliness_lost_status_
   RCPPUTILS_TSA_GUARDED_BY(internalMutex_);
 
-  std::atomic_bool incompatible_qos_changes_;
-  eprosima::fastdds::dds::OfferedIncompatibleQosStatus incompatible_qos_status_
-  RCPPUTILS_TSA_GUARDED_BY(internalMutex_);
-
   std::mutex * conditionMutex_ RCPPUTILS_TSA_GUARDED_BY(internalMutex_);
   std::condition_variable * conditionVariable_ RCPPUTILS_TSA_GUARDED_BY(internalMutex_);
 };
diff --git a/include/rmw_fastrtps_shared_cpp/custom_subscriber_info.hpp b/include/rmw_fastrtps_shared_cpp/custom_subscriber_info.hpp
index a130f2c..3dec7b1 100644
--- a/include/rmw_fastrtps_shared_cpp/custom_subscriber_info.hpp
+++ b/include/rmw_fastrtps_shared_cpp/custom_subscriber_info.hpp
@@ -89,7 +89,6 @@ public:
     deadline_changes_(false),
     liveliness_changes_(false),
     sample_lost_changes_(false),
-    incompatible_qos_changes_(false),
     conditionMutex_(nullptr),
     conditionVariable_(nullptr)
   {
@@ -147,12 +146,6 @@ public:
     eprosima::fastdds::dds::DataReader *,
     const eprosima::fastdds::dds::SampleLostStatus &) final;
 
-  RMW_FASTRTPS_SHARED_CPP_PUBLIC
-  void
-  on_requested_incompatible_qos(
-    eprosima::fastdds::dds::DataReader *,
-    const eprosima::fastdds::dds::RequestedIncompatibleQosStatus &) final;
-
   // EventListenerInterface implementation
   RMW_FASTRTPS_SHARED_CPP_PUBLIC
   bool
@@ -250,10 +243,6 @@ private:
   eprosima::fastdds::dds::SampleLostStatus sample_lost_status_
   RCPPUTILS_TSA_GUARDED_BY(internalMutex_);
 
-  std::atomic_bool incompatible_qos_changes_;
-  eprosima::fastdds::dds::RequestedIncompatibleQosStatus incompatible_qos_status_
-  RCPPUTILS_TSA_GUARDED_BY(internalMutex_);
-
   std::mutex * conditionMutex_ RCPPUTILS_TSA_GUARDED_BY(internalMutex_);
   std::condition_variable * conditionVariable_ RCPPUTILS_TSA_GUARDED_BY(internalMutex_);
 
diff --git a/src/custom_publisher_info.cpp b/src/custom_publisher_info.cpp
index 9fc6e40..fdbdfbe 100644
--- a/src/custom_publisher_info.cpp
+++ b/src/custom_publisher_info.cpp
@@ -13,11 +13,8 @@
 // limitations under the License.
 
 #include "rmw_fastrtps_shared_cpp/custom_publisher_info.hpp"
-
 #include "fastdds/dds/core/status/BaseStatus.hpp"
 #include "fastdds/dds/core/status/DeadlineMissedStatus.hpp"
-
-#include "event_helpers.hpp"
 #include "types/event_types.hpp"
 
 EventListenerInterface *
@@ -79,25 +76,6 @@ void PubListener::on_liveliness_lost(
   }
 }
 
-void PubListener::on_offered_incompatible_qos(
-  eprosima::fastdds::dds::DataWriter * /* writer */,
-  const eprosima::fastdds::dds::OfferedIncompatibleQosStatus & status)
-{
-  std::lock_guard<std::mutex> lock(internalMutex_);
-
-  // the change to incompatible_qos_status_ needs to be mutually exclusive with
-  // rmw_wait() which checks hasEvent() and decides if wait() needs to be called
-  ConditionalScopedLock clock(conditionMutex_, conditionVariable_);
-
-  // Assign absolute values
-  incompatible_qos_status_.last_policy_id = status.last_policy_id;
-  incompatible_qos_status_.total_count = status.total_count;
-  // Accumulate deltas
-  incompatible_qos_status_.total_count_change += status.total_count_change;
-
-  incompatible_qos_changes_.store(true, std::memory_order_relaxed);
-}
-
 bool PubListener::hasEvent(rmw_event_type_t event_type) const
 {
   assert(rmw_fastrtps_shared_cpp::internal::is_event_supported(event_type));
@@ -106,8 +84,6 @@ bool PubListener::hasEvent(rmw_event_type_t event_type) const
       return liveliness_changes_.load(std::memory_order_relaxed);
     case RMW_EVENT_OFFERED_DEADLINE_MISSED:
       return deadline_changes_.load(std::memory_order_relaxed);
-    case RMW_EVENT_OFFERED_QOS_INCOMPATIBLE:
-      return incompatible_qos_changes_.load(std::memory_order_relaxed);
     default:
       break;
   }
@@ -157,18 +133,6 @@ bool PubListener::takeNextEvent(rmw_event_type_t event_type, void * event_info)
         deadline_changes_.store(false, std::memory_order_relaxed);
       }
       break;
-    case RMW_EVENT_OFFERED_QOS_INCOMPATIBLE:
-      {
-        auto rmw_data = static_cast<rmw_requested_qos_incompatible_event_status_t *>(event_info);
-        rmw_data->total_count = incompatible_qos_status_.total_count;
-        rmw_data->total_count_change = incompatible_qos_status_.total_count_change;
-        rmw_data->last_policy_kind =
-          rmw_fastrtps_shared_cpp::internal::dds_qos_policy_to_rmw_qos_policy(
-          incompatible_qos_status_.last_policy_id);
-        incompatible_qos_status_.total_count_change = 0;
-        incompatible_qos_changes_.store(false, std::memory_order_relaxed);
-      }
-      break;
     default:
       return false;
   }
diff --git a/src/custom_subscriber_info.cpp b/src/custom_subscriber_info.cpp
index 6c24c35..92a4bd5 100644
--- a/src/custom_subscriber_info.cpp
+++ b/src/custom_subscriber_info.cpp
@@ -17,7 +17,6 @@
 #include "fastdds/dds/core/status/DeadlineMissedStatus.hpp"
 #include "fastdds/dds/core/status/LivelinessChangedStatus.hpp"
 
-#include "event_helpers.hpp"
 #include "types/event_types.hpp"
 
 EventListenerInterface *
@@ -99,25 +98,6 @@ void SubListener::on_sample_lost(
   sample_lost_changes_.store(true, std::memory_order_relaxed);
 }
 
-void SubListener::on_requested_incompatible_qos(
-  eprosima::fastdds::dds::DataReader * /* reader */,
-  const eprosima::fastdds::dds::RequestedIncompatibleQosStatus & status)
-{
-  std::lock_guard<std::mutex> lock(internalMutex_);
-
-  // the change to incompatible_qos_status_ needs to be mutually exclusive with
-  // rmw_wait() which checks hasEvent() and decides if wait() needs to be called
-  ConditionalScopedLock clock(conditionMutex_, conditionVariable_);
-
-  // Assign absolute values
-  incompatible_qos_status_.last_policy_id = status.last_policy_id;
-  incompatible_qos_status_.total_count = status.total_count;
-  // Accumulate deltas
-  incompatible_qos_status_.total_count_change += status.total_count_change;
-
-  incompatible_qos_changes_.store(true, std::memory_order_relaxed);
-}
-
 bool SubListener::hasEvent(rmw_event_type_t event_type) const
 {
   assert(rmw_fastrtps_shared_cpp::internal::is_event_supported(event_type));
@@ -128,8 +108,6 @@ bool SubListener::hasEvent(rmw_event_type_t event_type) const
       return deadline_changes_.load(std::memory_order_relaxed);
     case RMW_EVENT_MESSAGE_LOST:
       return sample_lost_changes_.load(std::memory_order_relaxed);
-    case RMW_EVENT_REQUESTED_QOS_INCOMPATIBLE:
-      return incompatible_qos_changes_.load(std::memory_order_relaxed);
     default:
       break;
   }
@@ -192,18 +170,6 @@ bool SubListener::takeNextEvent(rmw_event_type_t event_type, void * event_info)
         sample_lost_changes_.store(false, std::memory_order_relaxed);
       }
       break;
-    case RMW_EVENT_REQUESTED_QOS_INCOMPATIBLE:
-      {
-        auto rmw_data = static_cast<rmw_requested_qos_incompatible_event_status_t *>(event_info);
-        rmw_data->total_count = incompatible_qos_status_.total_count;
-        rmw_data->total_count_change = incompatible_qos_status_.total_count_change;
-        rmw_data->last_policy_kind =
-          rmw_fastrtps_shared_cpp::internal::dds_qos_policy_to_rmw_qos_policy(
-          incompatible_qos_status_.last_policy_id);
-        incompatible_qos_status_.total_count_change = 0;
-        incompatible_qos_changes_.store(false, std::memory_order_relaxed);
-      }
-      break;
     default:
       return false;
   }
diff --git a/src/rmw_event.cpp b/src/rmw_event.cpp
index ccc5375..6ba8323 100644
--- a/src/rmw_event.cpp
+++ b/src/rmw_event.cpp
@@ -16,7 +16,6 @@
 
 #include "rmw/impl/cpp/macros.hpp"
 
-#include "event_helpers.hpp"
 #include "rmw_fastrtps_shared_cpp/custom_event_info.hpp"
 #include "rmw_fastrtps_shared_cpp/rmw_common.hpp"
 #include "types/event_types.hpp"
@@ -26,9 +25,7 @@ static const std::unordered_set<rmw_event_type_t> g_rmw_event_type_set{
   RMW_EVENT_REQUESTED_DEADLINE_MISSED,
   RMW_EVENT_LIVELINESS_LOST,
   RMW_EVENT_OFFERED_DEADLINE_MISSED,
-  RMW_EVENT_MESSAGE_LOST,
-  RMW_EVENT_OFFERED_QOS_INCOMPATIBLE,
-  RMW_EVENT_REQUESTED_QOS_INCOMPATIBLE
+  RMW_EVENT_MESSAGE_LOST
 };
 
 namespace rmw_fastrtps_shared_cpp
@@ -41,29 +38,6 @@ bool is_event_supported(rmw_event_type_t event_type)
   return g_rmw_event_type_set.count(event_type) == 1;
 }
 
-rmw_qos_policy_kind_t dds_qos_policy_to_rmw_qos_policy(
-  eprosima::fastdds::dds::QosPolicyId_t policy_id)
-{
-  using eprosima::fastdds::dds::QosPolicyId_t;
-
-  switch (policy_id) {
-    case QosPolicyId_t::DURABILITY_QOS_POLICY_ID:
-      return RMW_QOS_POLICY_DURABILITY;
-    case QosPolicyId_t::DEADLINE_QOS_POLICY_ID:
-      return RMW_QOS_POLICY_DEADLINE;
-    case QosPolicyId_t::LIVELINESS_QOS_POLICY_ID:
-      return RMW_QOS_POLICY_LIVELINESS;
-    case QosPolicyId_t::RELIABILITY_QOS_POLICY_ID:
-      return RMW_QOS_POLICY_RELIABILITY;
-    case QosPolicyId_t::HISTORY_QOS_POLICY_ID:
-      return RMW_QOS_POLICY_HISTORY;
-    case QosPolicyId_t::LIFESPAN_QOS_POLICY_ID:
-      return RMW_QOS_POLICY_LIFESPAN;
-    default:
-      return RMW_QOS_POLICY_INVALID;
-  }
-}
-
 }  // namespace internal
 
 rmw_ret_t
